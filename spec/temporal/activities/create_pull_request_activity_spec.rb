# frozen_string_literal: true

require "rails_helper"

RSpec.describe Activities::CreatePullRequestActivity do
  let(:activity) { described_class.new }
  let(:project) { create(:project) }
  let(:issue) { create(:issue, project: project) }
  let(:agent_run) { create(:agent_run, :with_git_context, :with_metrics, project: project, issue: issue) }
  let(:github_client) { instance_double(GithubClient) }
  let(:pr_response) { Struct.new(:html_url, :number).new("https://github.com/owner/repo/pull/42", 42) }

  before do
    allow(GithubClient).to receive(:new).and_return(github_client)
    allow(github_client).to receive(:create_pull_request).and_return(pr_response)
    allow(github_client).to receive(:add_labels_to_issue)
  end

  describe "#execute" do
    it "creates a pull request via the GitHub API" do
      expect(github_client).to receive(:create_pull_request).with(
        project.full_name,
        base: project.default_branch,
        head: agent_run.branch_name,
        title: "Fix ##{issue.github_number}: #{issue.title}",
        body: a_string_including("Closes ##{issue.github_number}")
      ).and_return(pr_response)

      result = activity.execute(agent_run_id: agent_run.id)

      expect(result[:pull_request_url]).to eq("https://github.com/owner/repo/pull/42")
      expect(result[:pull_request_number]).to eq(42)
    end

    it "marks the agent run as completed with PR details" do
      activity.execute(agent_run_id: agent_run.id)

      agent_run.reload
      expect(agent_run.status).to eq("completed")
      expect(agent_run.pull_request_url).to eq("https://github.com/owner/repo/pull/42")
      expect(agent_run.pull_request_number).to eq(42)
    end

    it "adds the paid-generated label to the PR" do
      expect(github_client).to receive(:add_labels_to_issue).with(
        project.full_name, 42, [ "paid-generated" ]
      )

      activity.execute(agent_run_id: agent_run.id)
    end

    it "logs the PR creation to agent run" do
      activity.execute(agent_run_id: agent_run.id)

      log = agent_run.agent_run_logs.last
      expect(log.log_type).to eq("system")
      expect(log.content).to include("https://github.com/owner/repo/pull/42")
    end

    it "includes agent stdout in the PR body when available" do
      agent_run.log!("stdout", "Here are the changes I made to fix the issue.")

      expect(github_client).to receive(:create_pull_request).with(
        anything,
        hash_including(
          body: a_string_including("Here are the changes I made")
            .and(including("Closes ##{issue.github_number}"))
        )
      ).and_return(pr_response)

      activity.execute(agent_run_id: agent_run.id)
    end

    it "uses fallback summary when no stdout is available" do
      expect(github_client).to receive(:create_pull_request).with(
        anything,
        hash_including(
          body: a_string_including("automatically generated by")
            .and(including("Closes ##{issue.github_number}"))
        )
      ).and_return(pr_response)

      activity.execute(agent_run_id: agent_run.id)
    end

    it "handles missing issue gracefully" do
      agent_run_no_issue = create(:agent_run, :with_custom_prompt, :with_git_context, project: project)

      expect(github_client).to receive(:create_pull_request).with(
        anything,
        hash_including(title: "Agent changes")
      ).and_return(pr_response)

      result = activity.execute(agent_run_id: agent_run_no_issue.id)
      expect(result[:pull_request_url]).to eq("https://github.com/owner/repo/pull/42")
    end

    it "does not fail when label addition fails" do
      allow(github_client).to receive(:add_labels_to_issue)
        .and_raise(GithubClient::ApiError.new("Label not found"))

      expect {
        activity.execute(agent_run_id: agent_run.id)
      }.not_to raise_error
    end

    it "raises ActiveRecord::RecordNotFound for invalid agent_run_id" do
      expect {
        activity.execute(agent_run_id: -1)
      }.to raise_error(ActiveRecord::RecordNotFound)
    end
  end
end
